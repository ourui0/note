

# Programming in C++

http://www.tiobe.com/tiobe-index/

http://survey.stackoverflow.co/

http://www.stroustrup.com/

## language

特定的**字母表上**按照**一定的规则**（语法）形成的符号串的集合

语言三要素——语法、语义、语用

### BNF 的核心组成

BNF 主要由一系列**产生式规则** 组成。每条规则都像是一个定义，告诉我们如何构建一个更大的结构。

每条规则包含三个部分：

1. **非终结符**：用尖括号括起来的名称，例如 `<digit>`, `<expression>`。它表示一个语法类别或结构，可以被进一步分解。
2. **终结符**：是语言中实际的字符或字符串（词法单元），例如 `+`, `if`, `(`， `"hello"`。它们是语法树的“叶子”，无法再被分解。
3. **定义符号**：通常写成 `::=`，意思是“被定义为”或“由...组成”。

**运算符**：

- **`|`** ： 表示“或”。用于列出多个可能的选项。
- **连接**： 符号的简单排列表示“接着”，即顺序必须严格匹配。

### 一个简单的例子：定义整数

让我们用 BNF 来定义一个简单的无符号整数（例如 1, 123, 0）。

```bnf
<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
<integer> ::= <digit> | <digit> <integer>
```

### BNF 的扩展：EBNF

原始的 BNF 非常基础，为了更方便地表示语法，人们创建了**扩展的巴科斯-瑙尔范式**。

EBNF 引入了额外的运算符，使规则更简洁：

- **`?`**： 可选元素。例如 `"+" <expression>?` 表示加号和一个可选的表达式。
- **`\*`**： 重复零次或多次。例如 `<digit>*` 表示零个或多个数字。
- **`+`**： 重复一次或多次。例如 `<digit>+` 表示至少一个数字（这直接定义了我们的 `<integer>`）。
- **`[ ]`**： 分组，常用于与 `|`, `?`, `*`, `+` 结合。

**使用 EBNF 重写上面的例子：**

ebnf

```
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
integer = digit+ ; (* 使用 + 表示一个或多个数字 *)
expression = number
           | expression "+" expression
           | expression "*" expression
           | "(" expression ")" ;
```

*(注意：EBNF 中也常用 `=` 代替 `::=`)*

可以看到，`integer` 的定义变得异常简洁。

## 内联函数

内联函数是一种编译器优化技术，它的核心思想是：**在编译时，将函数调用语句直接替换为函数体本身的代码**。

### 一个简单的比喻：

- **普通函数调用**：就像你在读一本书，看到一个术语“光合作用”，下面写着“（详见附录A）”。你需要翻到书后的附录A去阅读定义，然后再翻回来继续读。这个过程有“跳转”的开销。
- **内联函数调用**：而内联函数则直接在这个术语“光合作用”的后面，用括号把附录A里的定义全文抄写一遍。这样你就不需要翻页了，阅读更流畅，但代价是这段定义文字重复出现了，使得当前页面变长了一点。

### 优点：主要目的是减少开销，提升性能

1. **消除函数调用开销**：每次调用普通函数，CPU都需要执行一系列操作：将返回地址、参数等压入栈（Stack），跳转到函数地址，执行函数代码，然后将结果返回，最后从栈中弹出数据并跳回调用处。对于非常小的函数，这个“准备工作”和“收尾工作”的开销可能比函数本身执行的开销还要大。内联函数直接省去了这些步骤。
2. **便于编译器优化**：因为代码被展开在调用处，编译器可以看到更大段的、连续的代码。这为编译器提供了更大的优化空间，例如**常量传播（Constant Propagation）**、**死代码消除（Dead Code Elimination）** 等优化可以更有效地进行。
   - *例子*：如果内联函数的一个参数是常量，编译器在展开后可以直接把这个常量代入计算，甚至直接算出结果。

### 缺点：不能滥用，否则会产生反效果

1. **代码膨胀（Code Bloat）**：这是内联函数最主要的缺点。如果一个函数很大又被多次调用，那么它的函数体会被复制很多次，导致最终编译出的可执行文件体积显著增大。这可能会降低CPU缓存（Cache）的命中率，反而导致性能下降。
2. **增加编译时间**：因为编译器需要处理并复制更多的代码。
3. **可能增加维护难度**：过度内联会使代码变得冗长，因为相同的逻辑分散在多个地方。
4. **对调试不友好**：调试器（Debugger）在处理内联函数时会比较困难，因为你可能无法像普通函数那样清晰地设置断点或查看调用栈。

### 使用

在C++中，主要有两种方式声明一个函数为内联函数：

1. **使用 `inline` 关键字**：
   在函数声明或定义前加上 `inline` 关键字。

   ```c++
   // 头文件 example.h
   #ifndef EXAMPLE_H
   #define EXAMPLE_H
   
   // 声明为内联函数
   inline int max(int a, int b) {
       return (a > b) ? a : b;
   }
   
   #endif
   ```

   

   **重要提示**：内联函数的定义（函数体）通常必须放在头文件（.h）中。因为编译时，编译器需要在每个调用它的源文件（.cpp）中看到它的完整定义才能进行“替换”。如果只放在某个源文件中，其他文件就无法内联它。

2. **在类定义内部直接定义函数**：
   在类内部直接实现的成员函数，会自动被视为建议内联的（但最终决定权仍在编译器）。

   ```c++
   class MyClass {
   public:
       // 构造函数在类内定义，默认为内联建议
       MyClass() : value(0) {}
   
       // Getter 函数在类内定义，默认为内联建议
       int getValue() const { return value; }
   
       // Setter 函数在类内定义，默认为内联建议
       void setValue(int v) { value = v; }
   
   private:
       int value;
   };
   ```

### 总结：何时使用内联函数？

遵循以下准则：

- **适合内联**：**小而频繁调用的函数**。通常是只有几行代码的“getter/setter”函数、简单的工具函数（如上面的 `max` 函数）。
- **不适合内联**：**大函数**（例如超过10行）、递归函数、虚函数（因为需要在运行时决定调用哪个函数，内联通常无法进行）。
- **核心原则**：**不要盲目使用内联**。首先应该编写清晰、可维护的代码，然后使用性能分析工具（Profiler）找出程序的性能瓶颈（Hotspots）。如果发现某个小函数的调用开销确实成为了瓶颈，再考虑将其内联。**基于性能分析数据来做优化，而不是凭感觉。**

## 作用域

### 为什么需要作用域？

1. **避免命名冲突**：允许在不同的上下文中使用相同的名字（例如，在不同的函数里都可以定义一个叫 `i` 的循环计数器），而不会相互干扰。
2. **数据封装与保护**：限制对变量的访问，防止程序的某些部分意外修改另一部分正在使用的数据，提高了程序的可靠性和安全性。
3. **管理内存生命周期**：与变量的生命周期密切相关。局部变量在离开作用域时会被自动销毁，从而释放内存。

### 主要类型（从常见到少见）

1. **局部作用域（块作用域）**

   - **在哪**： inside任何一对大括号 `{}` 里（比如函数、循环、if语句内部）。

   - **特点**： 在这里定义的变量（局部变量）只在当前 `{}` 内有效。括号结束，变量就被销毁。

   - **例子**：

     cpp

     ```c++
     void func() {
         int x = 10; // x 的作用域开始
         if (true) {
             int y = 20; // y 只在这个if块里有效
         } // y 的作用域结束，被销毁
         // cout << y; // 错误！y 已经没了
     } // x 的作用域结束
     ```

     

2. **全局作用域**

   - **在哪**： 在所有函数和代码块**之外**。

   - **特点**： 在这里定义的变量（全局变量）在整个程序中都有效，任何函数都能使用它。

   - **例子**：

     cpp

     ```c++
     #include <iostream>
     int globalVar = 50; // 全局变量，作用域开始
     
     void printIt() {
         std::cout << globalVar; // ✅ 任何函数都能访问
     }
     
     int main() {
         std::cout << globalVar; // ✅
         return 0;
     }
     // globalVar 的作用域到此文件末尾结束
     ```

     

3. **命名空间作用域**

   - **目的**： 用来管理和隔离全局名字，防止命名冲突。

   - **如何使用**： 用 `namespace` 定义，用 `::` 或 `using` 来访问。

   - **例子**：

     cpp

     ```c++
     namespace MyStuff {
         int value = 100;
     }
     int main() {
         std::cout << MyStuff::value; // 用 :: 访问
         return 0;
     }
     ```

     

4. **类作用域**

   - **在哪**： 在 `class` 或 `struct` 的内部。

   - **特点**： 类的成员（变量和函数）属于类的作用域。需要通过类的对象（`.`）或类名（`::` for静态成员）来访问。

   - **例子**：

     ```c++
     class MyClass {
     public:
         int data; // 成员变量，在类作用域内
         void func() { } // 成员函数
     };
     int main() {
         MyClass obj;
         obj.data = 10; // 通过对象 . 访问
         obj.func();
         return 0;
     }
     ```

- **隐藏规则**： 内层作用域的变量会**遮盖**外层同名的变量。

  cpp

  ```c++
  int x = 1; // 全局变量 x
  int main() {
      int x = 2; // 局部变量 x，遮盖了全局的 x
      cout << x; // 输出 2（使用的是局部变量）
      cout << ::x; // 输出 1（使用 :: 显式访问全局变量）
      return 0;
  }
  ```

## namespace（**命名空间**）

namespace 是一种作用域，用于将代码（如变量、函数、类）组织到逻辑组中，以防止**命名冲突**。相当于公司里的**部门**，以对**张三**，就有比如**“研发部的张三”**和**“销售部的张三”**。

**核心目的：解决全局命名空间污染问题。**

### 定义与使用

#### 1. 定义命名空间

使用 `namespace` 关键字来定义。

cpp

```c++
namespace MyNamespace {
    // 可以包含变量、函数、类、嵌套命名空间等
    int value = 42;

    void myFunction() {
        // ... 函数实现
    }

    class MyClass {
        // ... 类定义
    };

    // 甚至可以嵌套
    namespace InnerNamespace {
        int innerValue = 100;
    }
}
```



#### 2. 使用命名空间中的成员

有几种方法来访问命名空间里的内容：

**a) 使用作用域解析运算符 `::`（最明确，最推荐）**
直接指明你要访问的成员属于哪个命名空间。

cpp

```c++
int main() {
    std::cout << MyNamespace::value << std::endl; // 输出 42
    MyNamespace::myFunction();
    MyNamespace::MyClass obj;

    std::cout << MyNamespace::InnerNamespace::innerValue << std::endl; // 输出 100
    return 0;
}
```



**b) 使用 `using` 声明**
将某个特定的名称引入当前作用域，之后就可以直接使用它。

cpp

```c++
int main() {
    using MyNamespace::value; // 声明：后面可以直接用 value
    using MyNamespace::myFunction; // 声明：后面可以直接用 myFunction

    std::cout << value << std::endl; // ✅ 不需要前缀了
    myFunction(); // ✅

    // MyClass obj; // ❌ 错误！没有对 MyClass 使用 using 声明
    MyNamespace::MyClass obj; // ✅ 仍需使用 ::
    return 0;
}
```



**c) 使用 `using namespace` 指令（慎用！）**
将整个命名空间的所有名称都引入当前作用域。**这是一种偷懒的方式，虽然方便，但容易重新引入命名冲突的风险，违背了使用命名空间的初衷。**

cpp

```c++
// 在函数内部使用：只在该函数内生效
int main() {
    using namespace MyNamespace; // 引入整个 MyNamespace

    std::cout << value << std::endl; // ✅
    myFunction(); // ✅
    MyClass obj; // ✅

    return 0;
}

// 在全局使用：在整个文件内生效（非常不推荐！）
// using namespace MyNamespace;
```



**最佳实践：** 在头文件中**绝对不要**使用 `using namespace ...;`，在源文件中也**尽量限制在函数内部使用**，优先选择 `::` 和 `using` 声明。

### 总结

| 特性                           | 描述                   | 推荐度         |
| :----------------------------- | :--------------------- | :------------- |
| **`Namespace::member`**        | 最清晰，完全避免冲突   | ⭐⭐⭐⭐⭐ **首选** |
| **`using Namespace::member;`** | 对单个成员很方便       | ⭐⭐⭐⭐ **良好**  |
| **`using namespace Name;`**    | 方便但危险，易引起冲突 | ⭐ **尽量避免** |

## 引用

**引用是一个变量的别名（Alias）**。它为已存在的变量提供了另一个名字。一旦一个引用被初始化为某个变量，那么就可以通过这个引用名称来操作该变量，就像使用原变量名一样。

**核心思想：** 一个变量，两个名字。

### 基本语法

#### 1. 创建引用

使用 `&` 符号来声明引用。**注意：这里的 `&` 是类型标识的一部分，不是取地址运算符。**

cpp

```c++
int main() {
    int original_var = 10;
    
    // 创建引用：语法是 `类型& 引用名 = 原变量名;`
    int& ref = original_var; // ref 现在是 original_var 的别名

    // 通过 ref 操作，就是在操作 original_var
    ref = 20; // 修改 ref 的值
    std::cout << original_var << std::endl; // 输出 20，original_var 也被改变了

    original_var = 30; // 修改 original_var
    std::cout << ref << std::endl; // 输出 30，ref 也跟着变了

    return 0;
}
```



#### 2. 关键特性

1. **必须初始化**：引用在创建时必须被初始化，指明它是哪个变量的别名。它不能像指针一样先声明为 `NULL` 再赋值。

   cpp

   ```c++
   int& ref; // ❌ 错误！引用必须初始化
   int& ref = original_var; // ✅ 正确
   ```

   

2. **不可重新绑定**：一旦引用初始化指向某个变量，它就不能再成为另一个变量的别名。它“从一而终”。

   cpp

   ```c++
   int a = 10;
   int b = 20;
   int& ref = a;
   ref = b; // 这行代码的意思不是让 ref 变成 b 的别名。
            // 而是将 b 的值（20）赋值给 ref 所引用的对象（a）。
            // 所以现在 a 的值变成了 20。
   ```

   

3. **没有空引用**：引用必须指向一个有效的对象，不能存在“空引用”（类似 `NULL` 指针的概念）。这使得引用比指针更安全。

### 应用

参数传递

```c++
cpp
// 1. 按值传递（失败）
void swap_fail(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    // 这里交换的只是函数内部的副本，外面的变量没变
}

// 2. 按指针传递（C风格，有效但繁琐）
void swap_pointer(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 3. 按引用传递（C++风格，有效且简洁）✅
void swap_ref(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    
    swap_fail(x, y);
    std::cout << x << ", " << y << std::endl; // 输出 5, 10，没变

    swap_pointer(&x, &y); // 需要传地址
    std::cout << x << ", " << y << std::endl; // 输出 10, 5，成功但麻烦

    swap_ref(x, y); // 直接传变量，语法清晰
    std::cout << x << ", " << y << std::endl; // 输出 5, 10，成功且方便

    return 0;
}
```

### 与指针对比

### 四、引用 vs. 指针 🥊

这是一个核心区别。引用通常被实现为一种“自动解引用的指针”，但语法和安全性上有很大不同。

| 特性         | **引用 (Reference)**                   | **指针 (Pointer)**                        |
| :----------- | :------------------------------------- | :---------------------------------------- |
| **语法**     | ⭐ 像普通变量一样操作，更简洁           | 🔄 需要使用 `*` 和 `&` 运算符，更复杂      |
| **初始化**   | ⚠️ **必须初始化**                       | ✅ 可以稍后初始化，甚至可以初始化为 `NULL` |
| **可重绑定** | 🔒 **不可以**，始终是同一变量的别名     | 🔄 **可以**，可以指向不同的变量            |
| **空值**     | 🚫 **不能为空**，必须指向有效对象       | ✅ 可以为 `nullptr`                        |
| **安全性**   | 🛡️ **更安全**，不存在空引用和野引用     | ☠️ 风险较高，可能产生空指针、野指针        |
| **内存操作** | 🎭 无法获取引用自身的地址（它就是别名） | 🔍 可以获取指针变量自身的地址              |

**简单比喻：** ✨

- **指针** 像是一张**名片** 📇，上面写着别人的地址。你可以换一张名片（指向不同的人），也可以有一张空名片（`NULL`）。
- **引用** 像是一个人的**外号** 🏷️。一旦这个外号给了某个人，它就一辈子跟着这个人，不能转给别人。而且一个人不能没有外号（必须初始化）。

### 其他类型的引用

1. **常量引用（const Reference）**：
   主要用于函数参数，表示函数不会通过这个引用修改值，如上面 `printStringEfficiently` 的例子。

2. **右值引用（Rvalue Reference）**：
   使用 `&&` 声明，是 C++11 引入的高级特性，用于实现**移动语义（Move Semantics）** 和**完美转发（Perfect Forwarding）**，能极大提升性能。这是更深入的话题。

   cpp

   ```c++
   void handleValue(int&& rval_ref) {
       // 这个函数知道它接收的是一个“即将消亡”的临时值
       // 可以安全地“偷”它的资源，而不是拷贝
   }
   handleValue(42); // 可以传递临时值（右值）
   ```

   

### 总结

- **用途1（主要）**：作为函数参数（**按引用传递**），用于修改外部变量或**避免大型数据拷贝**（用 `const T&`）。
- **用途2**：作为函数返回值（返回引用允许函数调用出现在赋值语句左边，如 `cout <<` 或 `operator[]`）。
- **核心优势**：比指针更安全、语法更简洁清晰。
- **核心限制**：必须初始化且不能更换目标。