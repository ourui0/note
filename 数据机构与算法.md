# 数据机构与算法

## 语言差异

### 1. C/C++：编译为原生机器码

- **执行方式**：直接编译成与特定硬件（CPU架构）和操作系统相关的**原生机器码（Native Machine Code）**。CPU 可以直接执行，没有中间层。
- **速度**：**最快**。因为它是直接与操作系统和硬件打交道的，没有任何中间抽象层，运行时开销极小。
- **原因**：
  - **无虚拟机/解释器开销**：运行时不需要一个额外的环境来翻译代码。
  - **极致的手动优化**：程序员可以对内存管理（如手动分配/释放内存）、指针操作、编译器优化选项（如GCC的 `-O3`）进行极致的控制，从而榨干硬件性能。
- **代价**：需要手动管理内存，容易出现内存泄漏、缓冲区溢出等问题，开发效率和安全性较低。

> **C++** 在加入了面向对象、模板等特性后，理论上可能会因虚函数（vtable查找）等机制带来极其微小的性能损耗，但通过现代编译器的优化（如内联等），其性能与 C 语言在绝大多数场景下是**同一级别**的。通常认为 “C/C++” 是性能的标杆。

------

### 2. Java：编译为字节码 + JVM（虚拟机）运行

- **执行方式**：先编译成与硬件无关的**字节码（Bytecode）**，然后在运行时由 **Java 虚拟机（JVM）** 来解释或编译执行。
- **速度**：**非常快，通常仅次于C/C++**。尤其是长时间运行的服务端应用，其性能甚至可以接近C++。
- **原因**：
  - **JIT 即时编译（Just-In-Time Compilation）**：这是 Java 性能的关键。JVM 会监控代码的运行频率，将频繁执行的“热点代码”（如循环、常用方法）**动态编译成本地机器码**并缓存起来，下次执行就直接用机器码，速度极快。JIT 还能根据程序运行的实际情况进行**运行时优化**。
  - **强大的垃圾回收（GC）**：虽然自动内存管理有开销，但现代GC算法（如G1、ZGC）非常高效，避免了手动管理可能带来的错误，整体开发效率和可靠性更高。
- **代价**：需要安装JVM环境，启动时有一个JVM初始化和“预热”（让JIT发挥作用）的过程，所以短期运行的命令行程序可能感觉启动较慢。

------

### 3. Python：解释器直接解释执行

- **执行方式**：**解释型语言**。Python 解释器在运行时直接逐行读取源代码（或预先编译好的.pyc字节码），然后将其翻译成机器指令执行。
- **速度**：**最慢**。通常比 C/C++/Java 慢几十倍甚至上百倍。
- **原因**：
  - **全局解释器锁（GIL）**：CPython（最主流的实现）中的GIL限制了在多核CPU上同一时间只能有一个线程执行Python字节码，严重制约了CPU密集型多线程程序的性能。
  - **动态类型**：变量类型在运行时才确定，解释器每次执行操作（如 `a + b`）都需要进行类型检查，增加了大量开销。
  - **运行时解释**：每一行代码都需要经过解释器的处理，而不是直接执行本地机器码。
- **代价**：速度慢是最大的代价。但其语法简洁、灵活，开发效率极高，是“用开发时间换运行时间”的典型代表。

------

### 总结对比表格

| 特性         | C/C++                                    | Java                                                    | Python                                                       |
| :----------- | :--------------------------------------- | :------------------------------------------------------ | :----------------------------------------------------------- |
| **执行方式** | 编译为原生机器码                         | 编译为字节码，由JVM（含JIT）执行                        | 解释器解释执行（或编译为字节码）                             |
| **速度**     | **最快**                                 | **非常快**（尤其是长期运行）                            | **慢**                                                       |
| **内存管理** | 手动管理                                 | 自动垃圾回收（GC）                                      | 自动垃圾回收（GC）                                           |
| **典型应用** | 操作系统、游戏引擎、高频交易、嵌入式系统 | 大型企业级应用、安卓App、后台服务、大数据框架（Hadoop） | Web开发（Django/Flask）、数据分析、机器学习（库底层是C++）、自动化脚本 |
| **优点**     | 极致性能、硬件级控制                     | 高性能、跨平台、健壮性、生态系统强大                    | 开发效率极高、语法简单、生态丰富                             |
| **缺点**     | 开发效率低、不安全、不易跨平台           | 需要JVM、内存占用相对较高、启动稍慢                     | 运行速度慢、GIL问题、动态类型易出错                          |

------

### 一个生动的比喻

- **C/C++**：就像是 **亲自下厨炒菜**。从切菜到调味都自己控制，可以做出一道最快、最符合自己口味的菜，但也很容易切到手或者把菜炒糊（出错）。
- **Java**：就像是 **使用高级智能炒菜机**。你把准备好的食材（字节码）放进去，机器（JVM）会先用自动模式（解释执行）试试，发现你经常做某道菜（热点代码），它就学习并优化流程，之后再用最优模式（JIT编译）来高速完成。又快又省心，但你需要先买这台机器（安装JRE）。
- **Python**：就像是 **打电话给外卖**。你只需要说“我要一份宫保鸡丁”（写代码），很快就能吃到（得到结果）。非常方便快捷，但外卖小哥（解释器）骑车送过来需要时间（运行慢），而且你可能无法对菜品做极致的个性化调整。

### 重要补充

- **库的影响**：对于 Python 和 Java，很多高性能计算库（如 Python 的 NumPy、Pandas、TensorFlow）其**底层核心都是用 C/C++/Fortran 实现的**。当你调用这些库时，实际上是在运行极速的 C 代码，所以性能瓶颈并不在 Python 本身。这就是为什么用 Python 做科学计算依然很快的原因。
- **不同实现**：我们通常讨论的是 **CPython**（速度慢，但有GIL）。还有其他实现如 **PyPy**（带JIT，速度更快），但生态兼容性不如CPython。
- **编程语言的选择**：速度不是选择语言的唯一标准。**开发效率、可维护性、生态系统、团队技能和项目需求**往往更重要。Python 在数据和AI领域的统治地位就证明了“开发效率”的价值。

## 数据结构

- **数据结构**是**底层实现**，是代码和数据的**具体组织方式**，决定了程序的效率和性能。
- **抽象数据类型**是**高层抽象**，是数据和操作的**逻辑描述**，定义了程序的设计和接口。

### 基本数据结构

数据结构是一种存储和组织数据的方式，以便于访问和修改。
‣ 例如：数组、链表。
• 不同类型的数据通常需要不同的数据结构。
• 同一类型的数据可以通过不同的数据结构来表示。



### 抽象数据类型

数据结构通常会提供一个接口。
‣ 该接口通常被称为抽象数据类型（ADT）。
‣ ADT 规定了数据结构"能够做什么"和"应该做什么"，但不规定"如何实现"这些操作。
• ADT示例：列表（List），支持 get、set、add、remove 等操作
• 数据结构示例：ArrayList、LinkedList...
• ADT 是逻辑描述，而数据结构是具体实现。
‣ 类似于 .h 头文件与 .cpp 实现文件的关系。
‣ 不同的数据结构可以实现相同的 ADT。



### 队列

队列是先进先出，栈是先进后出。

• The **first-in-first-out (FIFO)** queuing discipline:

items are removed in the same order they are added.

**•** **FIFO** Queue:

**‣**Add(x) or **Enqueue(x)**: add to the end of the queue

**‣**Remove() or **Dequeue()**: remove the first item from the queue

 <img src="C:\Users\34021\AppData\Roaming\Typora\typora-user-images\image-20250911141203669.png" alt="image-20250911141203669" style="zoom:50%;" /><img src="C:\Users\34021\AppData\Roaming\Typora\typora-user-images\image-20250911141310226.png" alt="image-20250911141310226" style="zoom:33%;" /> 

The **Deque** (Double-Ended Queue) ADT represents a sequence of items with a 

front and a back, which supports the following operations:



## 分治策略

**分治策略的核心思想是：将一个复杂的大问题分解成若干个规模较小、但结构与原问题相似的子问题；递归地解决这些子问题，然后将子问题的解合并起来，最终得到原问题的解。**

简单来说，就是 **“分而治之，各个击破”**。

### 在计算机科学中的经典应用

1. **归并排序**

   - **分解**：将一个大数组递归地分成两半，直到每个子数组只剩下一个元素（一个元素的数组自然是有序的）。
   - **解决**：递归地对子数组进行排序（实际上，分解到最小后，“解决”步骤什么都不做）。
   - **合并**：将两个已经排序好的子数组合并成一个新的有序数组。这是归并排序的核心和精髓。

   ```cpp
   #include <iostream>
   #include <vector>
   using namespace std;
   
   // 合并两个已排序的子数组
   void merge(vector<int>& arr, int left, int mid, int right) {
       int n1 = mid - left + 1; // 左子数组的大小
       int n2 = right - mid;    // 右子数组的大小
       
       // 创建临时数组
       vector<int> L(n1), R(n2);
       
       // 拷贝数据到临时数组
       for (int i = 0; i < n1; i++)
           L[i] = arr[left + i];
       for (int j = 0; j < n2; j++)
           R[j] = arr[mid + 1 + j];
       
       // 合并临时数组回原数组
       int i = 0, j = 0, k = left;
       while (i < n1 && j < n2) {
           if (L[i] <= R[j]) {
               arr[k] = L[i];
               i++;
           } else {
               arr[k] = R[j];
               j++;
           }
           k++;
       }
       
       // 拷贝剩余元素
       while (i < n1) {
           arr[k] = L[i];
           i++;
           k++;
       }
       
       while (j < n2) {
           arr[k] = R[j];
           j++;
           k++;
       }
   }
   
   // 归并排序主函数
   void mergeSort(vector<int>& arr, int left, int right) {
       if (left < right) {
           // 找到中间点
           int mid = left + (right - left) / 2;
           
           // 递归排序左右两部分
           mergeSort(arr, left, mid);
           mergeSort(arr, mid + 1, right);
           
           // 合并已排序的两部分
           merge(arr, left, mid, right);
       }
   }
   
   // 打印数组的辅助函数
   void printArray(const vector<int>& arr) {
       for (int num : arr)
           cout << num << " ";
       cout << endl;
   }
   
   // 测试代码
   int main() {
       vector<int> arr = {12, 11, 13, 5, 6, 7};
       
       cout << "原始数组: ";
       printArray(arr);
       
       mergeSort(arr, 0, arr.size() - 1);
       
       cout << "排序后数组: ";
       printArray(arr);
       
       return 0;
   }
   ```

   

2. **快速排序**

   - **分解**：选择一个“基准”元素，将数组重新排列，所有比基准小的放在左边，比基准大的放在右边（分区操作）。这样原问题就被分解为基准的左、右两个子数组。
   - **解决**：递归地对左、右两个子数组进行快速排序。
   - **合并**：因为子数组已经是原地排序的，所以不需要合并步骤，整个数组自然就已经有序了。

3. **二分查找**

   - 虽然通常不被直接归类为严格的分治（因为它通常只需要解决一个子问题，无需合并），但其思想是分治的完美体现：每次都将搜索范围**分解**为一半，只在其中一半中**解决**问题，然后直接得到答案。

4. **大规模计算**

   - 比如MapReduce编程模型，就是分治思想的极致应用。它将海量数据**分解（Map）** 到成千上万的服务器上并行处理，然后将所有服务器的结果**合并（Reduce）** 成最终结果。

### 递归树

 <img src="C:\Users\34021\AppData\Roaming\Typora\typora-user-images\image-20250918141258408.png" alt="image-20250918141258408" style="zoom: 25%;" />

### 主定理

#### 主定理的适用形式

主定理适用于以下形式的递归式：

**T(n) = a · T(n/b) + f(n)**

其中：

- **n** 是问题的规模。
- **a ≥ 1** 是递归产生的子问题数量。
- **b > 1** 是每次递归后问题规模缩小的倍数。
- **f(n)** 是一个函数，表示将问题分解和合并子解所花费的时间（即除递归调用外的代价）。

#### 主定理的几种情况


$$
T(n) = a \cdot T(n/b) + \Theta(n^d)
$$

$$
T(n) =
\begin{cases} 
\Theta(n^d \lg n) & \text{if } a = b^d \\
\Theta(n^d) & \text{if } a < b^d \\
\Theta(n^{\log_b a}) & \text{if } a > b^d
\end{cases}
$$
**递归算法的总成本取决于递归树中“工作量”是如下分布的。**

| 情况      | 比较关系 | 成本主导层               | 直观解释                                                     |
| :-------- | :------- | :----------------------- | :----------------------------------------------------------- |
| **Case1** | `a<bᵈ`   | **顶层 (Root)**          | 合并成本极高，像是一个昂贵的“经理”，自己干了大部分活，只把少量琐事分给下属。总时间由经理决定。 |
| **Case2** | `a=bᵈ`   | **所有层 (Every Level)** | 完美平衡。每一层的工作量乘以层数就是总时间。                 |
| **Case3** | `a>bᵈ`   | **底层(Leaves)**         | 子问题数量爆炸，像是一个庞大的“基层 workforce”。尽管每个员工（叶子节点）处理的事很简单，但员工数量巨大，总时间由所有员工的总工时决定。 |

### Ruduce and Conquer

**核心思想**：分治策略的特例。**每次递归只进入一个子问题**进行求解，合并步骤通常很简单甚至没有。也称为“减小而治之”。

#### The Search Problem

确认一个元素是否存在在一个数组中:

+ 若有序，可以使用二分查找O(log n)
  + **递归式**：`T(n) = T(n/2) + Θ(1)` -> `O(log n)`
+ 若无序，则最快就是遍历(暂时无证明)

#### Peak finding

