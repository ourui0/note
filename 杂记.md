# 算法杂记

## 单调栈

**单调栈**是一种特殊的栈，里面的内容单调，定义非常简单，和它的名字相同，但是他能用来解决寻找**下一个更大（更小）**的元素

这是为什么？

接下来用一个经典例子来解释

给定一个数组，找到右边第一个比它大的数

**输入**[2,1,2,4,3]

**输出**[4,2,4,-1,-1]

现在我们来模拟解题过程

1.初始化一个空栈，

2.遍历数组中的每一个元素

3.对于当前元素arr[i]:

+ **while** (栈不为空 **并且** 当前元素 `nums[i]` > 栈顶元素)：
  - **弹出**栈顶元素。这意味着：**当前元素 `nums[i]` 就是被弹出元素的“下一个更大元素”**。
  - 我们将这个对应关系（被弹出元素 -> `nums[i]`) 记录下来。
+ **将**当前元素 `nums[i]` 的**索引**（或值）压入栈中。
+ （这样就能保证栈内元素从底到顶始终是**单调递减**的） 

4.遍历结束后，如果栈中还有元素，说明这些元素右边没有比它们更大的元素，它们的结果记为 -1。

**一步步拆解上面的数组 `[2, 1, 2, 4, 3]`：**

| 当前元素 | 操作                                                         | 栈 (底 -> 顶) | 说明/结果记录                                               |
| :------- | :----------------------------------------------------------- | :------------ | :---------------------------------------------------------- |
| 2        | 栈空，直接入栈                                               | [2]           |                                                             |
| 1        | 1 < 栈顶(2)，直接入栈                                        | [2, 1]        |                                                             |
| 2        | 2 > 栈顶(1)，**弹出1**，记录 `1 -> 2` 2 == 栈顶(2)，**入栈** | [2, 2]        | 1 的下一个更大元素是 2                                      |
| 4        | 4 > 栈顶(2)，**弹出2**，记录 `2 -> 4` 4 > 栈顶(2)，**弹出2**，记录 `2 -> 4` 栈空，**入栈** | [4]           | 第二个 2 的下一个更大元素是 4 第一个 2 的下一个更大元素是 4 |
| 3        | 3 < 栈顶(4)，直接入栈                                        | [4, 3]        |                                                             |
| **结束** | 栈中剩余元素 [4, 3]，它们右边没有更大元素，记录 `4 -> -1`, `3 -> -1` |               |                                                             |

**代码示例**：

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

vector<int> nextGreaterElement(const vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1); // 初始化结果数组，全部为-1
    stack<int> st; // 单调栈，存储的是元素的索引
    
    // 遍历数组
    for (int i = 0; i < n; i++) {
        // 当栈不为空且当前元素大于栈顶元素对应的值时
        while (!st.empty() && nums[i] > nums[st.top()]) {
            // 栈顶元素的下一个更大元素就是当前元素
            result[st.top()] = nums[i];
            st.pop(); // 弹出栈顶元素
        }
        // 将当前元素的索引入栈
        st.push(i);
    }
    
    return result;
}

int main() {
    vector<int> nums = {2, 1, 2, 4, 3};
    vector<int> result = nextGreaterElement(nums);
    
    cout << "输入数组: ";
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;
    
    cout << "下一个更大元素: ";
    for (int res : result) {
        cout << res << " ";
    }
    cout << endl;
    
    return 0;
}
```

