# 数据机构与算法

## 语言差异

### 1. C/C++：编译为原生机器码

- **执行方式**：直接编译成与特定硬件（CPU架构）和操作系统相关的**原生机器码（Native Machine Code）**。CPU 可以直接执行，没有中间层。
- **速度**：**最快**。因为它是直接与操作系统和硬件打交道的，没有任何中间抽象层，运行时开销极小。
- **原因**：
  - **无虚拟机/解释器开销**：运行时不需要一个额外的环境来翻译代码。
  - **极致的手动优化**：程序员可以对内存管理（如手动分配/释放内存）、指针操作、编译器优化选项（如GCC的 `-O3`）进行极致的控制，从而榨干硬件性能。
- **代价**：需要手动管理内存，容易出现内存泄漏、缓冲区溢出等问题，开发效率和安全性较低。

> **C++** 在加入了面向对象、模板等特性后，理论上可能会因虚函数（vtable查找）等机制带来极其微小的性能损耗，但通过现代编译器的优化（如内联等），其性能与 C 语言在绝大多数场景下是**同一级别**的。通常认为 “C/C++” 是性能的标杆。

------

### 2. Java：编译为字节码 + JVM（虚拟机）运行

- **执行方式**：先编译成与硬件无关的**字节码（Bytecode）**，然后在运行时由 **Java 虚拟机（JVM）** 来解释或编译执行。
- **速度**：**非常快，通常仅次于C/C++**。尤其是长时间运行的服务端应用，其性能甚至可以接近C++。
- **原因**：
  - **JIT 即时编译（Just-In-Time Compilation）**：这是 Java 性能的关键。JVM 会监控代码的运行频率，将频繁执行的“热点代码”（如循环、常用方法）**动态编译成本地机器码**并缓存起来，下次执行就直接用机器码，速度极快。JIT 还能根据程序运行的实际情况进行**运行时优化**。
  - **强大的垃圾回收（GC）**：虽然自动内存管理有开销，但现代GC算法（如G1、ZGC）非常高效，避免了手动管理可能带来的错误，整体开发效率和可靠性更高。
- **代价**：需要安装JVM环境，启动时有一个JVM初始化和“预热”（让JIT发挥作用）的过程，所以短期运行的命令行程序可能感觉启动较慢。

------

### 3. Python：解释器直接解释执行

- **执行方式**：**解释型语言**。Python 解释器在运行时直接逐行读取源代码（或预先编译好的.pyc字节码），然后将其翻译成机器指令执行。
- **速度**：**最慢**。通常比 C/C++/Java 慢几十倍甚至上百倍。
- **原因**：
  - **全局解释器锁（GIL）**：CPython（最主流的实现）中的GIL限制了在多核CPU上同一时间只能有一个线程执行Python字节码，严重制约了CPU密集型多线程程序的性能。
  - **动态类型**：变量类型在运行时才确定，解释器每次执行操作（如 `a + b`）都需要进行类型检查，增加了大量开销。
  - **运行时解释**：每一行代码都需要经过解释器的处理，而不是直接执行本地机器码。
- **代价**：速度慢是最大的代价。但其语法简洁、灵活，开发效率极高，是“用开发时间换运行时间”的典型代表。

------

### 总结对比表格

| 特性         | C/C++                                    | Java                                                    | Python                                                       |
| :----------- | :--------------------------------------- | :------------------------------------------------------ | :----------------------------------------------------------- |
| **执行方式** | 编译为原生机器码                         | 编译为字节码，由JVM（含JIT）执行                        | 解释器解释执行（或编译为字节码）                             |
| **速度**     | **最快**                                 | **非常快**（尤其是长期运行）                            | **慢**                                                       |
| **内存管理** | 手动管理                                 | 自动垃圾回收（GC）                                      | 自动垃圾回收（GC）                                           |
| **典型应用** | 操作系统、游戏引擎、高频交易、嵌入式系统 | 大型企业级应用、安卓App、后台服务、大数据框架（Hadoop） | Web开发（Django/Flask）、数据分析、机器学习（库底层是C++）、自动化脚本 |
| **优点**     | 极致性能、硬件级控制                     | 高性能、跨平台、健壮性、生态系统强大                    | 开发效率极高、语法简单、生态丰富                             |
| **缺点**     | 开发效率低、不安全、不易跨平台           | 需要JVM、内存占用相对较高、启动稍慢                     | 运行速度慢、GIL问题、动态类型易出错                          |

------

### 一个生动的比喻

- **C/C++**：就像是 **亲自下厨炒菜**。从切菜到调味都自己控制，可以做出一道最快、最符合自己口味的菜，但也很容易切到手或者把菜炒糊（出错）。
- **Java**：就像是 **使用高级智能炒菜机**。你把准备好的食材（字节码）放进去，机器（JVM）会先用自动模式（解释执行）试试，发现你经常做某道菜（热点代码），它就学习并优化流程，之后再用最优模式（JIT编译）来高速完成。又快又省心，但你需要先买这台机器（安装JRE）。
- **Python**：就像是 **打电话给外卖**。你只需要说“我要一份宫保鸡丁”（写代码），很快就能吃到（得到结果）。非常方便快捷，但外卖小哥（解释器）骑车送过来需要时间（运行慢），而且你可能无法对菜品做极致的个性化调整。

### 重要补充

- **库的影响**：对于 Python 和 Java，很多高性能计算库（如 Python 的 NumPy、Pandas、TensorFlow）其**底层核心都是用 C/C++/Fortran 实现的**。当你调用这些库时，实际上是在运行极速的 C 代码，所以性能瓶颈并不在 Python 本身。这就是为什么用 Python 做科学计算依然很快的原因。
- **不同实现**：我们通常讨论的是 **CPython**（速度慢，但有GIL）。还有其他实现如 **PyPy**（带JIT，速度更快），但生态兼容性不如CPython。
- **编程语言的选择**：速度不是选择语言的唯一标准。**开发效率、可维护性、生态系统、团队技能和项目需求**往往更重要。Python 在数据和AI领域的统治地位就证明了“开发效率”的价值。

## 数据结构

- **数据结构**是**底层实现**，是代码和数据的**具体组织方式**，决定了程序的效率和性能。
- **抽象数据类型**是**高层抽象**，是数据和操作的**逻辑描述**，定义了程序的设计和接口。

### 基本数据结构

数据结构是一种存储和组织数据的方式，以便于访问和修改。
‣ 例如：数组、链表。
• 不同类型的数据通常需要不同的数据结构。
• 同一类型的数据可以通过不同的数据结构来表示。



### 抽象数据类型

数据结构通常会提供一个接口。
‣ 该接口通常被称为抽象数据类型（ADT）。
‣ ADT 规定了数据结构"能够做什么"和"应该做什么"，但不规定"如何实现"这些操作。
• ADT示例：列表（List），支持 get、set、add、remove 等操作
• 数据结构示例：ArrayList、LinkedList...
• ADT 是逻辑描述，而数据结构是具体实现。
‣ 类似于 .h 头文件与 .cpp 实现文件的关系。
‣ 不同的数据结构可以实现相同的 ADT。



### 队列

队列是先进先出，栈是先进后出。

• The **first-in-first-out (FIFO)** queuing discipline:

items are removed in the same order they are added.

**•** **FIFO** Queue:

**‣**Add(x) or **Enqueue(x)**: add to the end of the queue

**‣**Remove() or **Dequeue()**: remove the first item from the queue


The **Deque** (Double-Ended Queue) ADT represents a sequence of items with a 

front and a back, which supports the following operations:



## 分治策略

**分治策略的核心思想是：将一个复杂的大问题分解成若干个规模较小、但结构与原问题相似的子问题；递归地解决这些子问题，然后将子问题的解合并起来，最终得到原问题的解。**

简单来说，就是 **“分而治之，各个击破”**。

### 在计算机科学中的经典应用

1. **归并排序**

   - **分解**：将一个大数组递归地分成两半，直到每个子数组只剩下一个元素（一个元素的数组自然是有序的）。
   - **解决**：递归地对子数组进行排序（实际上，分解到最小后，“解决”步骤什么都不做）。
   - **合并**：将两个已经排序好的子数组合并成一个新的有序数组。这是归并排序的核心和精髓。

   ```c++
   #include <iostream>
   #include <vector>
   using namespace std;
   
   // 合并两个已排序的子数组
   void merge(vector<int>& arr, int left, int mid, int right) {
       int n1 = mid - left + 1; // 左子数组的大小
       int n2 = right - mid;    // 右子数组的大小
       
       // 创建临时数组
       vector<int> L(n1), R(n2);
       
       // 拷贝数据到临时数组
       for (int i = 0; i < n1; i++)
           L[i] = arr[left + i];
       for (int j = 0; j < n2; j++)
           R[j] = arr[mid + 1 + j];
       
       // 合并临时数组回原数组
       int i = 0, j = 0, k = left;
       while (i < n1 && j < n2) {
           if (L[i] <= R[j]) {
               arr[k] = L[i];
               i++;
           } else {
               arr[k] = R[j];
               j++;
           }
           k++;
       }
       
       // 拷贝剩余元素
       while (i < n1) {
           arr[k] = L[i];
           i++;
           k++;
       }
       
       while (j < n2) {
           arr[k] = R[j];
           j++;
           k++;
       }
   }
   
   // 归并排序主函数
   void mergeSort(vector<int>& arr, int left, int right) {
       if (left < right) {
           // 找到中间点
           int mid = left + (right - left) / 2;
           
           // 递归排序左右两部分
           mergeSort(arr, left, mid);
           mergeSort(arr, mid + 1, right);
           
           // 合并已排序的两部分
           merge(arr, left, mid, right);
       }
   }
   
   // 打印数组的辅助函数
   void printArray(const vector<int>& arr) {
       for (int num : arr)
           cout << num << " ";
       cout << endl;
   }
   
   // 测试代码
   int main() {
       vector<int> arr = {12, 11, 13, 5, 6, 7};
       
       cout << "原始数组: ";
       printArray(arr);
       
       mergeSort(arr, 0, arr.size() - 1);
       
       cout << "排序后数组: ";
       printArray(arr);
       
       return 0;
   }
   ```

   

2. **快速排序**

   - **分解**：选择一个“基准”元素，将数组重新排列，所有比基准小的放在左边，比基准大的放在右边（分区操作）。这样原问题就被分解为基准的左、右两个子数组。
   - **解决**：递归地对左、右两个子数组进行快速排序。
   - **合并**：因为子数组已经是原地排序的，所以不需要合并步骤，整个数组自然就已经有序了。

3. **二分查找**

   - 虽然通常不被直接归类为严格的分治（因为它通常只需要解决一个子问题，无需合并），但其思想是分治的完美体现：每次都将搜索范围**分解**为一半，只在其中一半中**解决**问题，然后直接得到答案。

4. **大规模计算**

   - 比如MapReduce编程模型，就是分治思想的极致应用。它将海量数据**分解（Map）** 到成千上万的服务器上并行处理，然后将所有服务器的结果**合并（Reduce）** 成最终结果。

### 递归树


### 主定理

#### 主定理的适用形式

主定理适用于以下形式的递归式：

**T(n) = a · T(n/b) + f(n)**

其中：

- **n** 是问题的规模。
- **a ≥ 1** 是递归产生的子问题数量。
- **b > 1** 是每次递归后问题规模缩小的倍数。
- **f(n)** 是一个函数，表示将问题分解和合并子解所花费的时间（即除递归调用外的代价）。

#### 主定理的几种情况


$$
T(n) = a \cdot T(n/b) + \Theta(n^d)
$$

$$
T(n) =
\begin{cases} 
\Theta(n^d \lg n) & \text{if } a = b^d \\
\Theta(n^d) & \text{if } a < b^d \\
\Theta(n^{\log_b a}) & \text{if } a > b^d
\end{cases}
$$
**递归算法的总成本取决于递归树中“工作量”是如下分布的。**

| 情况      | 比较关系 | 成本主导层               | 直观解释                                                     |
| :-------- | :------- | :----------------------- | :----------------------------------------------------------- |
| **Case1** | `a<bᵈ`   | **顶层 (Root)**          | 合并成本极高，像是一个昂贵的“经理”，自己干了大部分活，只把少量琐事分给下属。总时间由经理决定。 |
| **Case2** | `a=bᵈ`   | **所有层 (Every Level)** | 完美平衡。每一层的工作量乘以层数就是总时间。                 |
| **Case3** | `a>bᵈ`   | **底层(Leaves)**         | 子问题数量爆炸，像是一个庞大的“基层 workforce”。尽管每个员工（叶子节点）处理的事很简单，但员工数量巨大，总时间由所有员工的总工时决定。 |

### Ruduce and Conquer

**核心思想**：分治策略的特例。**每次递归只进入一个子问题**进行求解，合并步骤通常很简单甚至没有。也称为“减小而治之”。

#### The Search Problem

确认一个元素是否存在在一个数组中:

+ 若有序，可以使用二分查找O(log n)
  + **递归式**：`T(n) = T(n/2) + Θ(1)` -> `O(log n)`
+ 若无序，则最快就是遍历(暂时无证明)

#### Peak finding

## 哈希表

## 平摊分析

### 定义

**平摊分析**是一种分析“平均成本”的技术，常用于数据结构分析

**核心思想** ： 即使是必须执行的昂贵操作，也可以通过不频繁的执行它们，使得每个操作的“平均成本”不会太高

+ 与平均情况分析的区别:

  + 平均情况分析: 假设输入数据不是“坏的”，遵循某种概率分布。
  + 平摊分析: 不依赖于输入数据的分布。它是一种最坏情况分析，但分析的对象是一个操作序列，而不是单个操作。
### 聚合方法
 这是一种最简单的平摊分析方法。它不区分操作类型，直接计算一个操作序列的总成本，然后除以操作次数，得到平均每次操作的成本。

 **公式** ： 聚合成本 = (m 次操作的最大总工作量) / m


### 平坦分析形式化定义

+ 符号:
  + c_i= 第 i 次操作的实际成本。
  + ĉ_i= 第 i 次操作的平摊成本。
  + n_i= 执行第 i 次操作时数据结构的大小。
+ 定义: 如果一个操作的平摊成本是 ĉ(n)，那么对于任意正整数 k，任何 k 次操作的总成本都满足：Σ c_i ≤ Σ ĉ(n_i)。
+ 推论:
  + k 次操作的总成本 ≤ Σĉ_i。
  + k 次操作的平均成本 ≤ (Σĉ_i) / k。
+ 重要提示: 不同的操作可以有不同的平摊成本。
+ 提问: 在循环数组队列中，是否可以设定 Insert的平摊成本 ĉ(n) = 3，Remove的平摊成本 ĉ(n) = 1？
+ 答案: 可以，只要这个设定能满足上述不等式定义。接下来的方法就是用来证明这种设定的合理性。
+ 解释: 这两页给出了平摊成本的严格数学定义，并指出可以为不同操作分配不同的成本，为后续的会计方法做铺垫。

### 会计方法
+ 比喻: 想象一个初始余额为 0 的银行账户。
+ 规则:
  + 每次执行操作时，支付其平摊成本 (ĉ_i)​ 的“费用”。
  + 用这笔费用来支付操作的实际成本 (c_i)。
    + 如果 ĉi ≥ c_i，那么多余的钱 (ĉi - c_i) 会作为“存款”存入银行账户。
    + 如果 ĉi < c_i，那么需要从银行账户中“取款” (c_i - ĉi) 来弥补差额。
+ 有效性条件: 对于任意操作序列，银行账户的余额 B = Σ(ĉ_i - c_i) 必须始终 ≥ 0。如果这个条件满足，那么总实际成本 Σc_i 就一定 ≤ 总平摊成本 Σĉ_i。
+ 解释: 会计方法是一种非常直观的平摊分析技术。它通过“存款”和“取款”的比喻，要求我们在廉价操作时预存“信用”，以便在昂贵操作时使用，从而保证总成本不超标。

### 势能方法

+ 概念: 这是最通用、最强大的平摊分析方法。
+ 定义:
  + Φ(D_i): 表示第 i 次操作后数据结构的“势能”。通常 Φ(D_0) = 0。
  + 平摊成本定义: ĉi = c_i + Φ(D_i) - Φ(D{i-1})。
    + 即：平摊成本 = 实际成本 + 势能的变化量。
+ 有效性条件: 对于所有 k，必须满足 Φ(D_k) ≥ Φ(D_0)（通常要求势能非负）。
+ 与会计方法的关系: 势能 Φ(D_i)类似于会计方法中的银行账户余额 B。势能方法更抽象，但也更灵活。
+ 应用示例（二进制计数器）:
  + 定义势能: Φ(D_i)= 二进制计数器中 1的个数。
  + 势能非负: 显然满足。
  + 计算:
    + c_i= (0→1 的位数) + (1→0 的位数)。
    + Φ(D_i) - Φ(D_{i-1})= (0→1 的位数) - (1→0 的位数)。
    + 代入公式: ĉ_i = c_i + ΔΦ = [(0→1)+(1→0)] + [(0→1) - (1→0)] = 2 * (0→1 的位数)。
    + 由于每次 Inc最多产生一次 0→1，所以 ĉ_i ≤ 2。
+ 解释: 势能方法通过定义一个数据结构的“势能”函数，将平摊成本与势能的变化绑定。它提供了更形式化的分析框架，适用于复杂场景。

## 并查集


## 图及其遍历

### 图的计算机表示
#### 邻接矩阵（Adjacency Matrix）

+ 定义：n×n矩阵，a_ij=1表示存在边(i,j)
+ 特点：
  + 无向图时矩阵对称
  + 空间复杂度：Θ(n²)，与边数m无关
+ A²的含义：表示长度为2的路径数量

现举一个例子。
下面构建一个无向图如下

```
A —— B
|    |
C —— D —— E
```

对应的邻接矩阵表示
```
    A  B  C  D  E
A   0  1  1  0  0
B   1  0  0  1  0  
C   1  0  0  0  1
D   0  1  0  0  1
E   0  0  1  1  0
```
代码表示

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <iomanip>
using namespace std;

const int MAX_SIZE = 100;  // 最大顶点数
const int INFINITY = 99999; // 表示无穷大（不相连）

class Graph {
private:
    int vertexCount;      // 顶点数量
    int edgeCount;        // 边数量
    bool isDirected;      // 是否为有向图
    vector<vector<int>> adjMatrix;  // 邻接矩阵
    vector<char> vertices; // 顶点数据（可选）

public:
    // 构造函数：初始化一个有vertexNum个顶点但没有边的图
    Graph(int vertexNum, bool directed = false) 
        : vertexCount(vertexNum), edgeCount(0), isDirected(directed) {
        
        // 初始化邻接矩阵（所有位置初始为0或INFINITY）
        adjMatrix.resize(vertexCount, vector<int>(vertexCount, 0));
        
        // 初始化顶点数据（A, B, C, ...）
        vertices.resize(vertexCount);
        for (int i = 0; i < vertexCount; i++) {
            vertices[i] = 'A' + i;
        }
    }

    // 获取顶点数量
    int V() const { return vertexCount; }
    
    // 获取边数量
    int E() const { return edgeCount; }
    
    // 判断是否为有向图
    bool directed() const { return isDirected; }
    
    // 插入边
    void addEdge(int v, int w, int weight = 1) {
        if (v < 0 || v >= vertexCount || w < 0 || w >= vertexCount) {
            cout << "顶点索引无效!" << endl;
            return;
        }
        
        if (adjMatrix[v][w] == 0) edgeCount++;
        
        adjMatrix[v][w] = weight;
        
        // 如果是无向图，对称位置也要设置
        if (!isDirected) {
            adjMatrix[w][v] = weight;
        }
    }
    
    // 删除边
    void removeEdge(int v, int w) {
        if (v < 0 || v >= vertexCount || w < 0 || w >= vertexCount) {
            cout << "顶点索引无效!" << endl;
            return;
        }
        
        if (adjMatrix[v][w] != 0) edgeCount--;
        
        adjMatrix[v][w] = 0;
        
        // 如果是无向图，对称位置也要清除
        if (!isDirected) {
            adjMatrix[w][v] = 0;
        }
    }
    
    // 检查边是否存在
    bool hasEdge(int v, int w) const {
        if (v < 0 || v >= vertexCount || w < 0 || w >= vertexCount) {
            return false;
        }
        return adjMatrix[v][w] != 0;
    }
    
    // 获取边的权重
    int getWeight(int v, int w) const {
        if (v < 0 || v >= vertexCount || w < 0 || w >= vertexCount) {
            return 0;
        }
        return adjMatrix[v][w];
    }
    
    // 打印邻接矩阵
    void printMatrix() const {
        cout << "邻接矩阵 (" << (isDirected ? "有向图" : "无向图") << "):" << endl;
        cout << "   ";
        
        // 打印列标题（顶点标签）
        for (int i = 0; i < vertexCount; i++) {
            cout << setw(3) << vertices[i] << " ";
        }
        cout << endl;
        
        // 打印矩阵内容
        for (int i = 0; i < vertexCount; i++) {
            cout << vertices[i] << "  ";
            for (int j = 0; j < vertexCount; j++) {
                cout << setw(3) << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
    
    // 计算顶点的度（无向图）或出度/入度（有向图）
    void calculateDegrees() {
        cout << "顶点度数:" << endl;
        
        if (!isDirected) {
            // 无向图：度=行中非零元素个数
            for (int i = 0; i < vertexCount; i++) {
                int degree = 0;
                for (int j = 0; j < vertexCount; j++) {
                    if (adjMatrix[i][j] != 0) degree++;
                }
                cout << "顶点 " << vertices[i] << " 的度: " << degree << endl;
            }
        } else {
            // 有向图：出度=行中非零元素个数，入度=列中非零元素个数
            for (int i = 0; i < vertexCount; i++) {
                int outDegree = 0, inDegree = 0;
                for (int j = 0; j < vertexCount; j++) {
                    if (adjMatrix[i][j] != 0) outDegree++;  // 出度
                    if (adjMatrix[j][i] != 0) inDegree++;   // 入度
                }
                cout << "顶点 " << vertices[i] << " 的出度: " << outDegree 
                     << ", 入度: " << inDegree << endl;
            }
        }
    }
};
int main() {
    // 创建一个无向图，有5个顶点
    Graph undirectedGraph(5, false);
    
    // 添加边
    undirectedGraph.addEdge(0, 1);  // A-B
    undirectedGraph.addEdge(0, 2);  // A-C
    undirectedGraph.addEdge(1, 3);  // B-D
    undirectedGraph.addEdge(2, 4);  // C-E
    undirectedGraph.addEdge(3, 4);  // D-E
    
    // 打印邻接矩阵
    undirectedGraph.printMatrix();
    cout << endl;
    
    // 计算度数
    undirectedGraph.calculateDegrees();
    cout << endl;
}
```

#### 邻接表（Adjacency List）
+ 定义：为每个节点维护一个邻居列表
+ 特点：
  + 无向图中每条边出现两次
  + 空间复杂度：Θ(n+m)

```cpp
#include <iostream>
using namespace std;

// 邻接表节点
struct AdjListNode {
    int dest;
    AdjListNode* next;
};

// 邻接表头节点
struct AdjList {
    AdjListNode* head;
};

class Graph {
private:
    int V;
    vector<AdjList> adj;

public:
    Graph(int V) {
        this->V = V;
        adj.resize(V);
        for (int i = 0; i < V; ++i) {
            adj[i].head = nullptr;
        }
    }

    // 添加边（无向图）
    void addEdge(int src, int dest) {
        // 添加到src到dest的边
        AdjListNode* newNode = new AdjListNode;
        newNode->dest = dest;
        newNode->next = adj[src].head;
        adj[src].head = newNode;

        // 添加到dest到src的边（无向图）
        newNode = new AdjListNode;
        newNode->dest = src;
        newNode->next = adj[dest].head;
        adj[dest].head = newNode;
    }

    void printGraph() {
        for (int v = 0; v < V; ++v) {
            AdjListNode* pCrawl = adj[v].head;
            cout << "顶点 " << v << " 的邻接列表: ";
            while (pCrawl) {
                cout << "-> " << pCrawl->dest;
                pCrawl = pCrawl->next;
            }
            cout << endl;
        }
    }
};
```

#### 两种表示的比较
+ 邻接矩阵优势：快速判断两节点是否相邻（O(1)）
+ 邻接表优势：快速遍历节点的所有邻居（O(deg(u))）
+ 选择依据：查询类型频率和图的稀疏性

### 广度优先搜索（BFS）
**基本思想**：
+ 层序遍历：从源节点s开始，按距离逐层访问节点
+ 数据结构：使用FIFO队列

**算法实现**
+ 节点状态：
  + WHITE：未发现
  + GRAY：已发现但未处理
  + BLACK：已处理完成
+ 关键变量：
  + u.dist：从s到u的距离
  + u.parent：在BFS树中的父节点

**性能分析**
+ 时间复杂度：Θ(n+m)
+ 正确性保证：
  + 访问所有从s可达的节点
  + 正确计算最短路径距离
  + 构建广度优先树

**处理非连通图**
+ 对每个连通分量分别执行BFS

**代码示例**

*邻接矩阵*
```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

void BFS_AdjMatrix(const vector<vector<int>>& matrix, int start) {
    int n = matrix.size(); // 图中顶点的总数
    vector<bool> visited(n, false); // 标记顶点是否被访问过
    queue<int> q; // 辅助队列

    // 从起始顶点开始BFS遍历
    visited[start] = true;
    q.push(start);

    cout << "BFS Traversal (Adjacency Matrix): ";

    while (!q.empty()) {
        int current = q.front();
        q.pop();
        cout << current << " "; // 处理当前顶点

        // 遍历所有顶点，检查是否是当前顶点的邻接点
        for (int i = 0; i < n; ++i) {
            // 如果顶点i与当前顶点相邻接，并且尚未被访问
            if (matrix[current][i] != 0 && !visited[i]) { // 通常用1或非0值表示存在边
                visited[i] = true;
                q.push(i);
            }
        }
    }
    cout << endl;
}

// 示例用法（仅供参考，用于理解数据结构）
/*
int main() {
    // 假设有4个顶点的图，用邻接矩阵表示
    vector<vector<int>> adjacencyMatrix = {
        {0, 1, 1, 0}, // 顶点0的边
        {1, 0, 1, 0}, // 顶点1的边
        {1, 1, 0, 1}, // 顶点2的边
        {0, 0, 1, 0}  // 顶点3的边
    };

    BFS_AdjMatrix(adjacencyMatrix, 2); // 从顶点2开始BFS遍历
    return 0;
}
*/
```
*邻接链表*
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <list>
using namespace std;

void BFS_AdjList(const vector<list<int>>& adj, int start) {
    int n = adj.size(); // 图中顶点的总数
    vector<bool> visited(n, false); // 标记顶点是否被访问过
    queue<int> q; // 辅助队列

    // 从起始顶点开始BFS遍历
    visited[start] = true;
    q.push(start);

    cout << "BFS Traversal (Adjacency List): ";

    while (!q.empty()) {
        int current = q.front();
        q.pop();
        cout << current << " "; // 处理当前顶点，这里简单地打印出来

        // 遍历当前顶点的所有邻接顶点
        for (int neighbor : adj[current]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
    cout << endl;
}

// 示例用法（仅供参考，用于理解数据结构）
/*
int main() {
    // 假设有4个顶点（0, 1, 2, 3）的图
    vector<list<int>> adjacencyList(4);
    // 添加边：0->1, 0->2, 1->2, 2->0, 2->3, 3->3
    adjacencyList[0].push_back(1);
    adjacencyList[0].push_back(2);
    adjacencyList[1].push_back(2);
    adjacencyList[2].push_back(0);
    adjacencyList[2].push_back(3);
    adjacencyList[3].push_back(3);

    BFS_AdjList(adjacencyList, 2); // 从顶点2开始BFS遍历
    return 0;
}
*/
```

总结比较：

| 特性 | 邻接链表 | 邻接矩阵 |
| :--- | :--- | :--- |
| **时间复杂度** | O(V + E) | O(V²) |
| **空间复杂度** | O(V + E) | O(V²) |
| **检查邻接点效率** | 直接遍历链表，效率高 | 需要遍历一行，效率相对较低 |
| **适用场景** | **稀疏图**（边数E远小于V²） | **稠密图**（边数E接近V²） |

### 深度优先搜索（DFS）

**基本思想**
+ **迷宫探索比喻**：使用"*粉笔*"标记和"*线团*"回溯
+ **递归本质**：深入探索直到死胡同，然后回溯

**算法实现**
+ 三种状态：
  + WHITE：未访问
  + GRAY：已发现但未完成处理
  + BLACK：已完成处理
+ 时间戳：
  + u.d：发现时间
  + u.f：完成时间

**关键性质**
+ 括号定理（Parenthesis Theorem）
  + 任意两节点的活跃区间要么完全分离，要么一个完全包含另一个
  + 反映了DFS树中的祖先-后代关系
+ 白路径定理（White-path Theorem）
  + v是u的后代 ⇔ 在u被发现时存在从u到v的全白节点路径

**边分类**
+ 树边：DFS森林中的边（v为WHITE）
+ 后向边：连接节点到祖先的边（v为GRAY）
+ 前向边：连接节点到后代的非树边（v为BLACK且u.d < v.d）
+ 横向边：其他情况（v为BLACK且u.d > v.d）

**无向图中的边分类**
+ 重要定理：在无向图的DFS中，每条边要么是树边，要么是后向边
+ 证明思路：考虑边第一次被探索时的节点颜色状态

**代码示例**

*邻接矩阵*
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Graph {
private:
    int numVertices;
    vector<vector<int>> adjMatrix;
    vector<bool> visited;

    void DFS_Recursive(int u) {
        visited[u] = true;
        cout << u << " "; // 处理当前节点，这里简单打印

        for (int v = 0; v < numVertices; ++v) {
            // 如果v是u的邻接点且未被访问
            if (adjMatrix[u][v] == 1 && !visited[v]) {
                DFS_Recursive(v);
            }
        }
    }

public:
    Graph(int n) : numVertices(n), adjMatrix(n, vector<int>(n, 0)), visited(n, false) {}

    void addEdge(int u, int v) {
        adjMatrix[u][v] = 1;
        adjMatrix[v][u] = 1; // 如果是有向图，则注释掉这一行
    }

    void DFS(int start) {
        fill(visited.begin(), visited.end(), false); // 重置访问标记
        cout << "DFS traversal starting from vertex " << start << ": ";
        DFS_Recursive(start);
        cout << endl;
    }
};

int main() {
    Graph g(5); // 创建一个有5个顶点的图

    // 添加边
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 4);

    g.DFS(0); // 从顶点0开始深度优先遍历
    return 0;
}
```
*邻接链表*
```cpp
#include <iostream>
#include <vector>
#include <list>
using namespace std;

class Graph {
private:
    int numVertices;
    vector<list<int>> adjList;
    vector<bool> visited;

    void DFS_Recursive(int u) {
        visited[u] = true;
        cout << u << " "; // 处理当前节点，这里简单打印

        for (int neighbor : adjList[u]) {
            if (!visited[neighbor]) {
                DFS_Recursive(neighbor);
            }
        }
    }

public:
    Graph(int n) : numVertices(n), adjList(n), visited(n, false) {}

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // 如果是有向图，则注释掉这一行
    }

    void DFS(int start) {
        fill(visited.begin(), visited.end(), false); // 重置访问标记
        cout << "DFS traversal starting from vertex " << start << ": ";
        DFS_Recursive(start);
        cout << endl;
    }
};

int main() {
    Graph g(5); // 创建一个有5个顶点的图

    // 添加边
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 4);

    g.DFS(0); // 从顶点0开始深度优先遍历
    return 0;
}
```

总结比较：
| 特性 | 邻接矩阵 | 邻接表 |
|:---|:---|:---|
|**空间复杂度**|​O(V²)|O(V + E)|
| **检查边是否存在** |​O(1)|O(degree(u))|
|**遍历所有邻接点**|​O(V)|O(degree(u))|
|**适用场景**|​稠密图|稀疏图|