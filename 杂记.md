# 杂记

## 单调栈

**单调栈**是一种特殊的栈，里面的内容单调，定义非常简单，和它的名字相同，但是他能用来解决寻找**下一个更大（更小）**的元素

这是为什么？

接下来用一个经典例子来解释

给定一个数组，找到右边第一个比它大的数

**输入**[2,1,2,4,3]

**输出**[4,2,4,-1,-1]

现在我们来模拟解题过程

1.初始化一个空栈，

2.遍历数组中的每一个元素

3.对于当前元素arr[i]:

+ **while** (栈不为空 **并且** 当前元素 `nums[i]` > 栈顶元素)：
  - **弹出**栈顶元素。这意味着：**当前元素 `nums[i]` 就是被弹出元素的“下一个更大元素”**。
  - 我们将这个对应关系（被弹出元素 -> `nums[i]`) 记录下来。
+ **将**当前元素 `nums[i]` 的**索引**（或值）压入栈中。
+ （这样就能保证栈内元素从底到顶始终是**单调递减**的） 

4.遍历结束后，如果栈中还有元素，说明这些元素右边没有比它们更大的元素，它们的结果记为 -1。

**一步步拆解上面的数组 `[2, 1, 2, 4, 3]`：**

| 当前元素 | 操作                                                         | 栈 (底 -> 顶) | 说明/结果记录                                               |
| :------- | :----------------------------------------------------------- | :------------ | :---------------------------------------------------------- |
| 2        | 栈空，直接入栈                                               | [2]           |                                                             |
| 1        | 1 < 栈顶(2)，直接入栈                                        | [2, 1]        |                                                             |
| 2        | 2 > 栈顶(1)，**弹出1**，记录 `1 -> 2` 2 == 栈顶(2)，**入栈** | [2, 2]        | 1 的下一个更大元素是 2                                      |
| 4        | 4 > 栈顶(2)，**弹出2**，记录 `2 -> 4` 4 > 栈顶(2)，**弹出2**，记录 `2 -> 4` 栈空，**入栈** | [4]           | 第二个 2 的下一个更大元素是 4 第一个 2 的下一个更大元素是 4 |
| 3        | 3 < 栈顶(4)，直接入栈                                        | [4, 3]        |                                                             |
| **结束** | 栈中剩余元素 [4, 3]，它们右边没有更大元素，记录 `4 -> -1`, `3 -> -1` |               |                                                             |

**代码示例**：

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

vector<int> nextGreaterElement(const vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1); // 初始化结果数组，全部为-1
    stack<int> st; // 单调栈，存储的是元素的索引
    
    // 遍历数组
    for (int i = 0; i < n; i++) {
        // 当栈不为空且当前元素大于栈顶元素对应的值时
        while (!st.empty() && nums[i] > nums[st.top()]) {
            // 栈顶元素的下一个更大元素就是当前元素
            result[st.top()] = nums[i];
            st.pop(); // 弹出栈顶元素
        }
        // 将当前元素的索引入栈
        st.push(i);
    }
    
    return result;
}

int main() {
    vector<int> nums = {2, 1, 2, 4, 3};
    vector<int> result = nextGreaterElement(nums);
    
    cout << "输入数组: ";
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;
    
    cout << "下一个更大元素: ";
    for (int res : result) {
        cout << res << " ";
    }
    cout << endl;
    
    return 0;
}
```

## 析构函数

### 📚 基本定义

**析构函数** 是一种特殊的成员函数，它在对象被销毁时**自动调用**，用于执行对象的清理工作。

#### 🔧 语法形式

```cpp
class ClassName {
public:
    ~ClassName();  // 析构函数声明
};

// 析构函数定义
ClassName::~ClassName() {
    // 清理代码
}
```

---

### 🎯 核心特性

#### 1. **命名规则**
- 函数名 = `~` + 类名
- **无参数**，**无返回值**
- **不能被重载**（一个类只能有一个析构函数）

#### 2. **调用时机**
析构函数在以下情况自动调用：

| 场景                                  | 示例                          |
| ------------------------------------- | ----------------------------- |
| 局部对象离开作用域                    | `{ MyClass obj; }` ← 右括号处 |
| 动态对象被 `delete`(不能是```free```) | `delete ptr;`                 |
| 对象成员所属对象销毁                  | 包含类对象销毁时              |
| 临时对象生命周期结束                  | 表达式计算完成后              |
| 栈展开时（异常处理）                  | 异常抛出时                    |

---

### 💻 详细代码示例

#### 示例1：基础用法

```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* m_data;
    size_t m_length;

public:
    // 🏗️ 构造函数 - 分配资源
    String(const char* str = "") {
        std::cout << "🔧 构造函数被调用" << std::endl;
        m_length = strlen(str);
        m_data = new char[m_length + 1];  // 🎯 动态分配内存
        strcpy(m_data, str);
    }

    // 🗑️ 析构函数 - 释放资源
    ~String() {
        std::cout << "🧹 析构函数被调用，释放资源: " << (m_data ? m_data : "null") << std::endl;
        delete[] m_data;  // 🎯 关键：释放动态内存
        m_data = nullptr;
    }

    // 其他成员函数
    void print() const {
        std::cout << "内容: " << m_data << std::endl;
    }
};

void demoBasic() {
    std::cout << "\n=== 示例1：基础用法 ===" << std::endl;
    { // 开始作用域
        String s1("Hello World");  // 🏗️ 构造函数调用
        s1.print();
    } // 🧹 离开作用域，析构函数自动调用
    
    std::cout << "作用域结束" << std::endl;
}
```

#### 示例2：动态对象管理

```cpp
class ResourceManager {
private:
    int* m_buffer;
    size_t m_size;

public:
    // 构造函数
    ResourceManager(size_t size) : m_size(size) {
        std::cout << "🔧 分配 " << size << " 个整数" << std::endl;
        m_buffer = new int[size];  // 🎯 动态分配
    }

    // 析构函数
    ~ResourceManager() {
        std::cout << "🧹 释放 " << m_size << " 个整数" << std::endl;
        delete[] m_buffer;  // 🎯 防止内存泄漏
        m_buffer = nullptr;
    }

    // 禁用拷贝（避免浅拷贝问题）
    ResourceManager(const ResourceManager&) = delete;
    ResourceManager& operator=(const ResourceManager&) = delete;
};

void demoDynamic() {
    std::cout << "\n=== 示例2：动态对象 ===" << std::endl;
    
    ResourceManager* ptr = new ResourceManager(100);  // 🏗️ 构造函数
    ptr->~ResourceManager();  // ❌ 可以显式调用，但通常不应该这样做
    delete ptr;  // 🧹 调用析构函数 + 释放内存
    
    std::cout << "动态对象已销毁" << std::endl;
}
```

#### 示例3：RAII模式

```cpp
#include <fstream>

// 🎯 RAII（Resource Acquisition Is Initialization）示例
class FileWrapper {
private:
    std::fstream m_file;

public:
    // 构造函数获取资源
    FileWrapper(const std::string& filename, std::ios::openmode mode = std::ios::in) {
        std::cout << "🔧 打开文件: " << filename << std::endl;
        m_file.open(filename, mode);
        if (!m_file.is_open()) {
            throw std::runtime_error("无法打开文件");
        }
    }

    // 析构函数释放资源
    ~FileWrapper() {
        std::cout << "🧹 关闭文件" << std::endl;
        if (m_file.is_open()) {
            m_file.close();  // 🎯 确保文件被关闭
        }
    }

    // 使用资源
    std::string readLine() {
        std::string line;
        std::getline(m_file, line);
        return line;
    }

    // 禁止拷贝
    FileWrapper(const FileWrapper&) = delete;
    FileWrapper& operator=(const FileWrapper&) = delete;
};

void demoRAII() {
    std::cout << "\n=== 示例3：RAII模式 ===" << std::endl;
    
    try {
        FileWrapper file("example.txt");  // 🏗️ 资源获取
        auto content = file.readLine();   // 🎯 使用资源
        std::cout << "读取内容: " << content << std::endl;
    } // 🧹 无论是否异常，文件都会被正确关闭
    catch (const std::exception& e) {
        std::cout << "错误: " << e.what() << std::endl;
    }
}
```

---

### ⚠️ 重要注意事项

#### 1. **虚析构函数**

```cpp
class Base {
public:
    // ✅ 如果类可能被继承，应该声明虚析构函数
    virtual ~Base() {
        std::cout << "Base 析构函数" << std::endl;
    }
};

class Derived : public Base {
private:
    int* m_data;
public:
    Derived() : m_data(new int[100]) {}
    
    // ✅ 正确：派生类析构函数自动为虚函数
    ~Derived() override {
        std::cout << "Derived 析构函数" << std::endl;
        delete[] m_data;
    }
};

void demoVirtualDestructor() {
    std::cout << "\n=== 虚析构函数示例 ===" << std::endl;
    
    Base* ptr = new Derived();
    delete ptr;  // 🎯 正确调用 Derived 和 Base 的析构函数
}
```

#### 2. **合成析构函数**

如果类没有定义析构函数，编译器会自动生成一个：

```cpp
class SimpleClass {
    int x, y;
public:
    // 编译器自动生成：~SimpleClass() {}
    // 对基本类型成员，合成析构函数什么也不做
};
```

---

### 🔄 与其他语言的对比

| 语言       | 类似机制                | 特点                     |
| ---------- | ----------------------- | ------------------------ |
| **C++**    | `~ClassName()`          | 确定性销毁，手动内存管理 |
| **Java**   | `finalize()`            | ❌ 已废弃，非确定性调用   |
| **C#**     | `IDisposable` + `using` | 确定性资源管理           |
| **Python** | `__del__()`             | 非确定性，依赖垃圾回收   |
| **Rust**   | `Drop trait`            | 确定性，所有权系统       |

---

### 🎯 最佳实践总结

1. **✅ RAII原则**：在构造函数中获取资源，在析构函数中释放
2. **✅ 虚析构函数**：基类声明虚析构函数
3. **✅ 异常安全**：析构函数不应该抛出异常
4. **❌ 避免手动调用**：除非在placement new等特殊场景
5. **✅ 遵循规则五**：如果需要自定义析构函数，通常也需要拷贝/移动控制成员

```cpp
// 🎯 现代C++推荐：使用智能指针避免手动析构
#include <memory>

void modernCppStyle() {
    std::cout << "\n=== 现代C++风格 ===" << std::endl;
    
    // 无需手动 delete，unique_ptr 自动管理生命周期
    auto ptr = std::make_unique<String>("Modern C++");
    ptr->print();
    
    std::cout << "离开作用域，智能指针自动清理..." << std::endl;
} // 🧹 自动调用析构函数
```

---

### 📊 可视化：对象生命周期

```
对象创建 → 构造函数 🏗️
    ↓
对象使用期
    ↓
对象销毁 → 析构函数 🧹
    ↓
资源释放 ✅
```

**关键要点**：析构函数是C++中资源管理的基石，它确保了对象在生命周期结束时能够正确地清理其占用的资源，是防止资源泄漏的核心机制。